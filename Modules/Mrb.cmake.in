# Once only!
include_guard(GLOBAL)

cmake_policy(PUSH)
cmake_minimum_required(VERSION 3.18.2 FATAL_ERROR)

include(CMakeFindDependencyMacro)
if (EXISTS ${CMAKE_SOURCE_DIR}/cetmodules)
  list(PREPEND CMAKE_MODULE_PATH ${CMAKE_SOURCE_DIR}/cetmodules/Modules
    ${CMAKE_SOURCE_DIR}/cetmodules/Modules/compat)
else()
  find_package(cetmodules @MRB_MIN_CETMODULES_VERSION@ REQUIRED)
endif()
include(CetCMakeEnv)
include(Compatibility)
include(ParseVersionString)

set(_mrb_find_package_flags REQUIRED QUIET EXACT)
set(_mrb_find_package_flag_vars REQUIRED QUIETLY VERSION_EXACT)

set(_mrb_find_package_version_supported 3.20.0)
if (CMAKE_VERSION VERSION_GREATER _mrb_find_package_version_supported)
  message(WARNING "unsupported CMake version ${CMAKE_VERSION}.
Contact mrb developers to request find_package() support")
endif()

# Intercept calls to find_package() for IN_TREE packages and make them
# do the right thing.
macro(find_package PKG)
  cmake_policy(PUSH)
  cmake_minimum_required(VERSION 3.18.2...3.20)
  if (${PKG}_IN_TREE)
    if (NOT CMAKE_DISABLE_FIND_PACKAGE_${PKG} OR
        "${ARGN}" MATCHES "(^|;)REQUIRED(;|$)")
      string(TOUPPER "${PKG}" _fp_PKG_UC)
      # May be modified by transitive dependency searches.
      set(${PKG}_FOUND TRUE)
      if (CETMODULES_CMAKE_MODULES_DIRECTORIES_PROJECT_${PKG})
        list(TRANSFORM CETMODULES_CMAKE_MODULES_DIRECTORIES_PROJECT_${PKG}
          PREPEND "${${PKG}_SOURCE_DIR}/" REGEX "^[^/]+" OUTPUT_VARIABLE _fp_module_path)
        list(PREPEND CMAKE_MODULE_PATH "${_fp_module_path}")
        unset(_fp_module_path)
      endif()
      if (DEFINED CACHE{CETMODULES_TRANSITIVE_DEPS_PROJECT_${PKG}})
        # Save the current value of CMAKE_FIND_PACKAGE_NAME.
        set(_fp_CMAKE_FIND_PACKAGE_NAME ${CMAKE_FIND_PACKAGE_NAME})
        # Set the variables find_dependency() expects to see.
        _mrb_set_find_package_env(${ARGV})
        if (NOT _fp_TRANSITIVE_DEPS_PROJECT_${PKG})
          string(REPLACE ";" "\n" _fp_TRANSITIVE_DEPS_PROJECT_${PKG}
            "${CETMODULES_TRANSITIVE_DEPS_PROJECT_${PKG}}")
        endif()
        cmake_language(EVAL CODE "${_fp_TRANSITIVE_DEPS_PROJECT_${PKG}}")
        set(CMAKE_FIND_PACKAGE_NAME ${_fp_CMAKE_FIND_PACKAGE_NAME})
      endif()
    endif()
    set(${_fp_PKG_UC}_FOUND ${PKG}_FOUND)
    unset(_fp_PKG_UC)
  else()
    _find_package(${ARGV})
  endif()
  cmake_policy(POP)
endmacro()

function(mrb_check_subdir_order)
  # Read the order determined by mrbsetenv
  set(prod_setup_file "${CMAKE_BINARY_DIR}/$ENV{MRB_PROJECT}-$ENV{MRB_PROJECT_VERSION}")
  file(READ "${prod_setup_file}" prod_setup)
  string(REPLACE "\n" ";" prod_setup "${prod_setup}")
  list(FILTER prod_setup INCLUDE REGEX "^# >> .* <<$")
  list(TRANSFORM prod_setup REPLACE "^# >> (.*) <<$" "\\1")

  # Now read the current subdirectory order.
  set(subdirs_file "${CMAKE_SOURCE_DIR}/.cmake_add_subdir")
  file(READ "${subdirs_file}" subdirs)
  string(REPLACE "\n" ";" subdirs "${subdirs}")
  list(FILTER subdirs INCLUDE REGEX "^add_subdirectory")
  list(TRANSFORM subdirs REPLACE "^add_subdirectory\\(([^)]+)\\).*$" "\\1")

  # Compare and complain.
  if (NOT "${subdirs}" STREQUAL "${prod_setup}")
    message(FATAL_ERROR "\
Current CMake subdirectory inclusion order is not consistent with current packages \
and their interdependencies.
Please run \"mrb uc\" to regenerate \${MRB_SOURCE}/CMakeLists.txt with \
subdirectories listed for inclusion in the correct order.\
")
  endif()
endfunction()

function(mrb_checkpoint)
  cet_checkpoint_cmp()
  cet_checkpoint_did()
endfunction()

function(mrb_process_checkpoints)
  cet_process_cmp()
  cet_process_did()
endfunction()

function(_mrb_set_find_package_env PKG)
  # Must match accepted argument list of find_package() for latest version of CMake.
  cmake_parse_arguments(PARSE_ARGV 1 _sfpe
    "CMAKE_FIND_ROOT_PATH_BOTH;CONFIG;EXACT;QUIET;MODULE;NO_CMAKE_BUILDS_PATH;NO_CMAKE_FIND_ROOT_PATH;NO_CMAKE_ENVIRONMENT_PATH;NO_CMAKE_PACKAGE_REGISTRY;NO_CMAKE_PATH;NO_CMAKE_SYSTEM_PACKAGE_REGISTRY;NO_CMAKE_SYSTEM_PATH;NO_DEFAULT_PATH;NO_PACKAGE_ROOT_PATH;NO_MODULE;NO_POLICY_SCOPE;NO_SYSTEM_ENVIRONMENT_PATH;ONLY_CMAKE_FIND_ROOT_PATH;REQUIRED"
    ""
    "COMPONENTS;CONFIGS;HINTS;NAMES;OPTIONAL_COMPONENTS;PATH_SUFFIXES;PATHS")
  # Name.
  set(CMAKE_FIND_PACKAGE_NAME ${PKG})
  # Flags.
  foreach(flag var IN ZIP_LISTS _mrb_find_package_flags _mrb_find_package_flag_vars)
    set(${PKG}_FIND_${var} ${_sfpe_${flag}} PARENT_SCOPE)
  endforeach()
  # Lists.
  set(${PKG}_FIND_COMPONENTS ${_sfpe_COMPONENTS} ${sfpe_OPTIONAL_COMPONENTS} PARENT_SCOPE)
  foreach(arg IN LISTS _sfpe_COMPONENTS)
    set(${PKG}_FIND_REQUIRED_${arg} TRUE PARENT_SCOPE)
  endforeach()
  foreach (arg IN LISTS _sfpe_OPTIONAL_COMPONENTS)
    set(${PKG}_FIND_REQUIRED_${arg} FALSE PARENT_SCOPE)
  endforeach()
  # Version constraint.
  list(POP_FRONT _sfpe_UNPARSED_ARGUMENTS VERSION)
  unset(VERSION_ARRAY_MIN)
  unset(VERSION_ARRAY_MAX)
  if (VERSION MATCHES "^(.*)(...(<)?(.*))?$")
    # Specified minimum version or version range.
    parse_version_string(${CMAKE_MATCH_1} SEP . VERSION_ARRAY_MIN)
    if (CMAKE_MATCH_2)
      # Range.
      set(${PKG}_FIND_VERSION_RANGE ${VERSION} PARENT_SCOPE)
      set(${PKG}_FIND_VERSION_MIN ${CMAKE_MATCH_1} PARENT_SCOPE)
      set(${PKG}_FIND_VERSION_MAX ${CMAKE_MATCH_4} PARENT_SCOPE)
      set(${PKG}_FIND_VERSION_RANGE_MIN INCLUDE PARENT_SCOPE)
      if (CMAKE_MATCH_3)
        set(${PKG}_FIND_VERSION_RANGE_MAX EXCLUDE PARENT_SCOPE)
      else()
        set(${PKG}_FIND_VERSION_RANGE_MAX INCLUDE PARENT_SCOPE)
      endif()
      parse_version_string(${CMAKE_MATCH_4} SEP . VERSION_ARRAY_MAX)
      foreach (minmax IN ITEMS MIN MAX)
        list(LENGTH VERSION_ARRAY_${minmax} VERSION_${minmax}_COUNT)
        set(${PKG}_FIND_VERSION_${minmax}_COUNT ${VERSION_${minmax}_COUNT} PARENT_SCOPE)
        if (minmax STREQUAL "MIN")
          set(${PKG}_FIND_VERSION ${CMAKE_MATCH_1} PARENT_SCOPE)
          set(${PKG}_FIND_VERSION_COUNT ${VERSION_${minmax}_COUNT} PARENT_SCOPE)
        endif()
        foreach (part IN ITEMS MAJOR MINOR PATCH TWEAK)
          list(POP_FRONT VERSION_ARRAY_${minmax} ${part})
          if (${part} STREQUAL "")
            set(${part} 0)
          endif()
          set(${PKG}_FIND_VERSION_${minmax}_${part} ${${part}} PARENT_SCOPE)
          if (minmax STREQUAL "MIN")
            set(${PKG}_FIND_VERSION_${part} ${${part}} PARENT_SCOPE)
          endif()
        endforeach()
      endforeach()
    else()
      # Minimum version only.
      list(LENGTH VERSION_ARRAY_MIN VERSION_COUNT)
      set(${PKG}_FIND_VERSION_COUNT ${VERSION_COUNT} PARENT_SCOPE)
      foreach (part IN ITEMS MAJOR MINOR PATCH TWEAK)
        list(POP_FRONT VERSION_ARRAY_MIN ${part})
        if (${part} STREQUAL "")
          set(${part} 0)
        endif()
        set(${PKG}_FIND_VERSION_${part} ${${part}} PARENT_SCOPE)
      endforeach()
    endif()
  endif()
  set(mmclear)
  if (NOT VERSION_ARRAY_MAX)
    set(mmclear MAX)
  endif()
  if (NOT VERSION_ARRAY_MIN)
    list(APPEND mmclear MIN)
    unset(${PKG}_FIND_VERSION PARENT_SCOPE)
    foreach (var IN ITEMS COUNT MAJOR MINOR PATCH TWEAK)
      set(${PKG}_FIND_VERSION_${var} 0 PARENT_SCOPE)
    endforeach()
  endif()
  foreach (minmax IN LISTS mmclear)
    unset(${PKG}_FIND_VERSION_${minmax} PARENT_SCOPE)
    foreach (var IN ITEMS COUNT MAJOR MINOR PATCH TWEAK)
      unset(${PKG}_FIND_VERSION_${minmax}_${var} PARENT_SCOPE)
    endforeach()
  endforeach()
endfunction()

mrb_check_subdir_order()

mrb_checkpoint()

cmake_policy(POP)
