#!/usr/bin/perl -w
########################################################################
# mrb gitCheckout - Check out repositories and suites from git into an
#                   mrb source area.
########################################################################

use strict;

########################################################################
# Modules.
use Cwd qw(chdir :DEFAULT);
use File::Basename;
use File::Spec;
use Getopt::Long;
use Pod::Usage;

########################################################################
# Preamble: configuration, globals and prototypes.
Getopt::Long::Configure(qw(no_ignore_case bundling require_order));

my $prog = basename($0);
my $options = {};
my $default_repo_type = "fnal";
my $known_suites =
  { larsoft => [qw(larcore lardata larevt larsim larg4 larreco
                   larana larexamples lareventdisplay larpandora
                   larwirecell larsoft)],
    art => [qw(cetlib_except cetlib fhiclcpp messagefacility
               canvas canvas_root_io art gallery critic)],
    critic => [qw(cetlib_except cetlib fhiclcpp messagefacility
                  canvas canvas_root_io art gallery critic)],
    gallery => [qw(cetlib_except cetlib fhiclcpp messagefacility
                   canvas canvas_root_io gallery)],
    larsoftobj => [qw(larcoreobj lardataobj larcorealg lardataalg larsoftobj)],
    uboone=> [qw(uboonecode ubutil uboonedata ublite ubana ubreco ubsim
                 ubevt ubraw ubcrt ubcore ubcv ubobj)]
  };
my $global_tree_ish;

my $version = "2.1.0";

# Declare prototypes for repository handlers here, implement wherever
# you like. Specify the appropriate handler in $repo_handlers, below.
sub fnal_repo;
sub github_repo;
sub repo_info;

# Declare known repo handlers.
my $repo_handlers =
  { fnal => \&fnal_repo,
    github => \&github_repo,
    bitbucket => undef, # Known but unimplemented currently.
    gitlab => undef, # Known but unimplemented currently.
    local => undef # Known but unimplemented currently.
  };

# Declare prototypes for repository post-processors here.
sub hub_fork($);
sub git_flow_init($);

# Declare URL verifiers here.
sub verified_fnal_url;
sub verified_github_url;

my @known_specs =
  ( repo_info("artdaq_core", fnal_repo("artdaq-core", "artdaq")),
    repo_info("lariatfragments",
              fnal_repo("lariat-online-lariatfragments", "lariat-online")),
    repo_info("lariatutil", fnal_repo("lardbt-lariatutil", "lardbt")),
    repo_info("fhiclcpp", fnal_repo("fhicl-cpp")),
    repo_info("lbne_raw_data", fnal_repo("lbne-raw-data")),
    repo_info("artdaq_core_demo", fnal_repo("artdaq-core-demo")),
    repo_info("artdaq_demo", fnal_repo("artdaq-demo")),
    repo_info("artdaq_utilities", fnal_repo("artdaq-utilities")),
    repo_info("artdaq_ganglia_plugin",
              fnal_repo("artdaq-utilities-ganglia-plugin",
                        "artdaq-utilities")),
    repo_info("artdaq_epics_plugin",
              fnal_repo("artdaq-utilities-epics-plugin",
                        "artdaq-utilities")),
    repo_info("artdaq_database",
              fnal_repo("artdaq-utilities-database",
                        "artdaq-utilities")),
    repo_info("artdaq_daqinterface",
              fnal_repo("artdaq-utilities-daqinterface",
                        "artdaq-utilities")),
    repo_info("artdaq_mpich_plugin",
              fnal_repo("artdaq-utilities-mpich-plugin",
                        "artdaq-utilities")),
    repo_info("artdaq_mfextensions",
              fnal_repo("mf-extensions-git")),
    repo_info("larana",
              fnal_repo("larana"),
              github_repo("larana", "LArSoft")),
    repo_info("larcore",
              fnal_repo("larcore"),
              github_repo("larcore", "LArSoft")),
    repo_info("larcorealg",
              fnal_repo("larcorealg"),
              github_repo("larcorealg", "LArSoft")),
    repo_info("larcoreobj",
              fnal_repo("larcoreobj"),
              github_repo("larcoreobj", "LArSoft")),
    repo_info("lardata",
              fnal_repo("lardata"),
              github_repo("lardata", "LArSoft")),
    repo_info("lardataalg",
              fnal_repo("lardataalg"),
              github_repo("lardataalg", "LArSoft")),
    repo_info("lardataobj",
              fnal_repo("lardataobj"),
              github_repo("lardataobj", "LArSoft")),
    repo_info("larevt",
              fnal_repo("larevt"),
              github_repo("larevt", "LArSoft")),
    repo_info("lareventdisplay",
              fnal_repo("lareventdisplay"),
              github_repo("lareventdisplay", "LArSoft")),
    repo_info("larexamples",
              fnal_repo("larexamples"),
              github_repo("larexamples", "LArSoft")),
    repo_info("larpandora",
              fnal_repo("larpandora"),
              github_repo("larpandora", "LArSoft")),
    repo_info("larsim",
              fnal_repo("larsim"),
              github_repo("larsim", "LArSoft")),
    repo_info("larreco",
              fnal_repo("larreco"),
              github_repo("larreco", "LArSoft")),
    repo_info("larg4",
              fnal_repo("larg4"),
              github_repo("larg4", "LArSoft")),
    repo_info("larwirecell",
              fnal_repo("larwirecell"),
              github_repo("larwirecell", "LArSoft")),
    repo_info("larsoftobj",
              fnal_repo("larsoftobj"),
              github_repo("larsoftobj", "LArSoft")),
    repo_info("larsoft",
              fnal_repo("larsoft"),
              github_repo("larsoft", "LArSoft"))
  );

my ($known_products); # Initialized on startup.

########################################################################
# Subroutines.

####################################
# process_args - process incoming arguments to a subroutine into a
#                hashref.
#
# Usage: process_args(@args)
#
# Positional arguments are saved (in order) as an array in
# $hash->{positional}.
sub process_args {
  my $args = { positional => [] };
  while (my $arg = shift) {
    if ($arg =~ m&^-(\w+)$&o) {
      $args->{${1}} = shift;
    } else {
      push @{$args->{positional}}, $arg;
    }
  }
  return $args;
}

####################################
# report - Print messages at the specified level.
#
# Usage: report(@msgs, kwargs)
#
# Keyword arguments: -level => "INFO"|"WARNING"|"ERROR"|"VERBOSE"
#                      Level of the provided message.
#
# WARNING and ERROR messages are sent to STDERR, all others to
# STDOUT.
sub report {
  my $args = process_args(@_);
  my $level = $args->{level} || "INFO";
  my $out = \*STDOUT;
  if ($level eq "WARNING" or $level eq "ERROR") {
    $out = \*STDERR;
  } elsif ($options->{quiet} or
             ($level eq "VERBOSE" and not $options->{verbose})) {
    return;
  }
  print $out "$level: ", join("", @{$args->{positional}}), "\n";
}


####################################
# error - Report an error and exit.
#
# Usage: error(@msgs)
#
# Keyword arguments: -exitval => #
#                      Exit code.
#                    -usage => 1|0
#                      Print short usage if true.
sub error {
  my $args = process_args(@_);
  my $exitval = $args->{exitval} || 1;
  report(@{$args->{positional}}, -level => "ERROR");
  if ($args->{usage} || 0) {
    pod2usage(-exitval => $exitval, -width => 132);
  } else {
    exit($exitval);
  }
}

####################################
# repo_args - Process args to repository handlers.
#
# Usage: repo_args(@args)
#
# Returns a tuple of ($product, $repo, $user).
sub repo_args {
  my $product = shift;
  $product or error("Product not specified!");
  my $repo = shift || $product;
  my $user = shift || $repo;
  return ($product, $repo, $user), @_;
}

####################################
# fnal_repo - Handle a FNAL Redmine repository specification.
#
# Usage: fnal_repo($product, $repo, $user)
#
# Returns a repo type info hashref.
sub fnal_repo {
  my ($repo, $user) = @_;
  $user = $repo unless $user;
  return { fnal => { repo => ${repo},
                     ssh_access => "p-${user}\@cdcvs.fnal.gov",
                     rw_url => "ssh://p-${user}\@cdcvs.fnal.gov/cvs/projects/${repo}",
                     ro_url => "http://cdcvs.fnal.gov/projects/${repo}",
                     post => \&git_flow_init,
                     url_picker => \&verified_fnal_url
                   }
         };
};

####################################
# github_repo - Handle a GitHub repository specification.
#
# Usage: github_repo($product, $repo, $githuborg, $githubuser)
#
# Returns a repo type info hashref.
sub github_repo {
  my ($repo, $ghorg) = @_;
  $ghorg = $repo unless $ghorg;
  return { github => { repo => "${repo}",
                       ssh_access => "git\@github.com",
                       rw_url => "git\@github.com:${ghorg}/${repo}.git",
                       ro_url => "https://github.com/${ghorg}/${repo}.git",
                       post => \&hub_fork,
                       url_picker => \&verified_github_url
                     }
         };
}

####################################
# repo_info - Return a composite repository info specification.
#
# Returns a composite repo info hashref
sub repo_info {
  my $result = { product => shift };
  foreach my $hashref (@_) {
    %$result = (%$result, %$hashref);
    if (exists $result->{types}) {
      push @{$result->{types}}, keys %$hashref;
    } else {
      $result->{types} = [keys %$hashref];
    }
  }
  return $result;
}

####################################
# repo_type_request - message text to file a feauture request to
#                     implement a repository handler.
#
# Usage: repo_type_request($type)
#
# Returns: message text.
sub repo_type_request {
  my $type = shift;
  return "file a feature request at
https://cdcvs.fnal.gov/redmine/projects/mrb/issues/new?issue[tracker_id]=2&issue[subject]=Need\%20git\%20checkout\%20support\%20for\%20$type\%20repositories";
}

####################################
# unimplemented_repo_type - report an error for an unimplemented
#                           repository type.
#
# Usage: unimplemented_repo_type($product, $repo, $user)
#
# Informs the user on the procedure for requesting support for the
# unimplemented type.
sub unimplemented_repo_type {
  my $type = shift;
  my ($product, $repo, $user) = repo_args(@_);
  error("Unimplemented handler \"$type\" for repository \"$repo\": ", repo_type_request($type));
}

####################################
# handle_repo - Invoke the correct repo handler.
#
# Usage: handle_repo($type, @handler_args)
#
# @handler_args are passed through to the invoked handler.
#
# Returns the return value of the invoked handler.
sub handle_repo {
  my $type = shift || $default_repo_type;
  unless (exists $repo_handlers->{$type}) {
    error("Unrecognized repo type $type or other repo handling error.");
  }
  my $handler = $repo_handlers->{$type};
  unless ($handler) {
    unimplemented_repo_type($type, @_);
  }
  return &{$handler}(@_);
}

####################################
# split_type_repo - Split the repo into type:repo
#
# Usage: split_type_repo($repo_clause)
#
# Returns a tuple of ($type, $value) from an input string of
# [<type>:]<value>.
sub split_type_repo {
  my $repo = shift;
  return ($repo =~ m&^(?:(.*?):)?(.*)$&);
}


####################################
# init_known_products - Initialize the $known_products and $known_products
#                    global hashes.
#
# Usage: init_known_products()
sub init_known_products {
  foreach my $repo_spec (@known_specs) {
    $known_products->{$repo_spec->{product}} = $repo_spec;
  }
}

####################################
# format_repo_info - Format a repo_info hash into a pretty string.
#
# Usage: format_repo_info(%repo_info)
#
# Returns a formatted human-readable string representing the repo_info
# hash.
sub format_repo_info(\%) {
  my $repo_info = shift;
  my @result =
    map { my $type = $_;
          my $repo = $repo_info->{$type}->{repo};
          sprintf("%s (%s) =>\n  { %s\n  }\n",
                  $repo, $type,
                  join(",\n    ",
                       sprintf("%s => %s", "product", $repo_info->{product}),
                       map { sprintf("%s => %s",
                                     $_,
                                     $repo_info->{$type}->{$_}); }
                       sort keys %{$repo_info->{$type}})
                 );
        } @{$repo_info->{types}};
  return join ('', @result);
}

####################################
# process_repo_spec - Process a repo spec into a repo_info hash
#
# Usage: process_repo_info($repo_spec)
#
# Returns the repo_info hash.
sub process_repo_spec {
  my $repo_spec = shift;
  my ($type, $product, $repo, $user, $user_url, $tree_ish);
  my %repo_info = ();
  if (($product, $user_url, $tree_ish) =
      ($repo_spec =~ m&^(?:(.*?)%)?(.*?://.*?)(?:@([^/]+))?$&)) {
    # [<product>%]<URL>[@<tree-ish>]
    $repo = $product || basename($user_url);
    $type = "user";
    %repo_info = (product => ${product} || ${repo},
                  origin => "user_url",
                  $type => {
                            repo => ${repo},
                            user_url => ${user_url},
                           });
  } elsif (($product, $repo, $user, $tree_ish) =
           ($repo_spec =~ m&^(.*?)(?:%(.*?)(?:%(.*))?)?(?:@(.*))?$&)) {
    # [<product>%][<type>:]<repo>[%<user>][@<tree-ish>] OR
    # [<type>:]<product>[@<tree-ish>]
    if ($repo) {
      ($type, $repo) = split_type_repo(${repo});
    } else {
      ($type, $repo) = split_type_repo(${product});
      $product = basename(${repo});
    }
    if (not $options->{"no-expand"}) {
      if (exists $known_products->{$product}) {
        %repo_info = %{$known_products->{$product}};
        $repo_info{origin} = "known_products";
      } else {
        my %candidate_products =
          map { my $ri = $_; if (grep { $_->{repo} eq $repo }
                                 (map { $ri->{$_}; } @{$ri->{types} }) ) { ($ri->{product} => $ri); } else { (); } }
                   @known_specs;
        if (scalar keys  %candidate_products > 1) {
          error("Multiple products referring to the same repository are not supported at this time.");
        } elsif (scalar keys %candidate_products) {
          %repo_info = %{(values %candidate_products)[0]};
          $repo_info{origin} = "known_repos";
          if ($type) {
            if ($repo_info{$type}->{repo} ne $repo) {
              error("Specified repository $repo is not valid for specified repository type $type.");
            }
          } else {
            my @candidate_types =
              grep { $repo_info{$_}->{repo} eq $repo } @{$repo_info{types}};
            if (scalar @candidate_types == 1) {
              $type = shift @candidate_types;
            } elsif ($options->{"repo-type"}) {
              if (grep { $options->{"repo-type"} eq $_; } @candidate_types) {
                $type = $options->{"repo-type"};
              } elsif (grep { $default_repo_type eq $_ ; } @candidate_types) {
                $type = $default_repo_type;
              } else {
                error("Unable to resolve ambiguous repository specification $repo: please specify repository type.");
              }
            }
          }
        }
      }
    }
    unless ($repo_info{origin}) {
      $type = $options->{"repo-type"} unless ${type};
      $user = basename($repo) unless ${user};
      %repo_info = (product => $product,
                    %{handle_repo($type ? lc $type : undef, $repo, $user)});
      $repo_info{origin} = "handled_repo";
    }
  } else {
    error("Unrecognized repo spec ${repo_spec}\n");
  }
  if (${tree_ish}) {
    $repo_info{"tree-ish"} = ${tree_ish};
  }
  $repo_info{type} = $type || $options->{"repo-type"} || $default_repo_type;
  report("Repository info:\n",
         format_repo_info(%repo_info),
         -level => "VERBOSE");
  return %repo_info;
}

####################################
# expand_suite - Expand recognized suites into their constituent
#                repositories.
#
# Usage: expand_suite($repo_spec)
#
# Returns: expanded list of repositories for the given suite or ().
#
# If the given suite also specifies a tree-ish, it is appended to each
# repository spec. version tags are translated to full suite version
# tags when appropriate.
sub expand_suite {
  my $repo_spec = shift;
  my ($suite, $treeish);
  my $known_suites_expr = join("|", sort keys %{$known_suites});
  report("Checking $repo_spec against $known_suites_expr", -level => "VERBOSE");
  if (($suite, $treeish) =
      ($repo_spec =~ m&^($known_suites_expr)_suite(?:@(.*))?$&o)) {
    report("Expanding $repo_spec");
  } else {
    return ();
  }
  if ($treeish and $treeish =~ m&^v\d+.*$&o) {
    $treeish = sprintf("%s_SUITE_${treeish}", uc ${suite});
    report("Using tag $treeish for suite $suite");
  }
  return map { sprintf("${_}%s", $treeish ? "\@${treeish}" : ""); }
    @{$known_suites->{$suite}};
}

####################################
# have_read_access - verify we have at least read access to the
#                    specified repository.
#
# Usage: have_read_acces($url)
#
# Returns true on success.
sub have_read_access {
  my $url = shift;
  return system(sprintf("git ls-remote -q '%s' >%s 2>&1",
                        $url,
                        File::Spec->devnull())) == 0;
}

####################################
# verified_url - Return a verified repository URL.
#
# Usage: verified_url($repo_info)
#
# Interrogates the provided repo_info hashref to ascertain the best URL
# to use to clone the repository.
#
# Returns a verified URL.
sub verified_url {
  my $type = shift;
  my $repo_info = shift;
  my $read_only = shift || $options->{"read-only"};
  return $repo_info->{url_picker} ? &{$repo_info->{url_picker}}($type, $repo_info, $read_only) :
    ($repo_info->{user_url} || $repo_info->{rw_url} || $repo_info->{ro_url});
}

sub verified_fnal_url {
  my ($type, $repo_info, $read_only)  = @_;
  if ($read_only and exists $repo_info->{ro_url}) {
    if (have_read_access($repo_info->{ro_url})) {
      return $repo_info->{ro_url};
    } else {
      error("Unable to verify read access to remote $repo_info->{ro_url}");
    }
  } elsif ($repo_info->{rw_url}) {
    if ($type eq "fnal" and
        exists $repo_info->{ssh_access}) {
      # We can verify write access to this one.
      report("Checking write access to $repo_info->{ssh_access}", -level => "VERBOSE");
      my $bad = `ssh $repo_info->{ssh_access} echo hi 2>&1 | grep -E 'Permission|authentication' | grep -v 'fake authentication' | wc -l`;
      if ($bad == 1) {
        report("Unable to verify write access for $repo_info->{repo}, falling back to read-only");
        return verified_fnal_url($type, $repo_info, 1);
      } else {
        return $repo_info->{rw_url};
      }
    } elsif (have_read_access($repo_info->{rw_url})) {
      return $repo_info->{rw_url};
    } else {
      error("Unable to verify at least read access to remote $repo_info->{rw_url}");
    }
  } else {
    error("Unable to ascertain URL for $repo_info->{repo}");
  }
}

sub verified_github_url {
  my ($type, $repo_info, $read_only)  = @_;
  if ($read_only and exists $repo_info->{ro_url}) {
    if (have_read_access($repo_info->{ro_url})) {
      return $repo_info->{ro_url};
    } else {
      error("Unable to verify read access to remote $repo_info->{ro_url}");
    }
  } elsif ($repo_info->{rw_url} and have_read_access($repo_info->{rw_url})) {
    # FIXME Could verify permission access using REST, but do simple
    # verificiation for now:
    return $repo_info->{rw_url};
  } elsif ($repo_info->{ro_url}) {
    return $repo_info->{ro_url};
  } else {
    error("Unable to verify at least read access to remote $repo_info->{rw_url} and no fallback R/O URL.");
  }
}

####################################
# clone_repo - Execute git clone for the specified URL.
#
# Usage: clone_repo($url, $destination)
sub clone_repo {
  my ($url, $destination) = @_;
  my @clone_cmd = (qw(git clone), $url, $destination);
  if ($options->{"dry-run"}) {
    report(sprintf("Would execute command %s", join(" ", @clone_cmd)),
           -level => "INFO");
  } else {
    report("Executing clone command: ", join(" ", @clone_cmd),
           -level => "VERBOSE");
    system(@clone_cmd) == 0 or
      error("Unable to execute clone command: ", join(" ", @clone_cmd));
  }
}

####################################
# checkout_tree_ish - Execute git checkout with the specified tree-ish.
#
# Usage: checkout_tree_ish($destination, $tree_ish)
# 
sub checkout_tree_ish {
  my ($destination, $tree_ish) = @_;
  my $checkout_cmd =
    sprintf("(cd \"%s\" && git checkout \"%s\")",
            File::Spec->catdir($ENV{MRB_SOURCE}, $destination),
            $tree_ish);
  system($checkout_cmd) == 0 or
    error("Unable to check out ${tree_ish} in ${destination}");
}

####################################
# git_flow_init - Initialize git flow for the specified repository.
#
# Usage: git_flow_init($destination)
#
sub git_flow_init($) {
  my $destination = shift;
  report("Initializing git flow for $destination", -level => 'VERBOSE');
  my $path = File::Spec->catdir($ENV{MRB_SOURCE}, $destination);
  # This elaborate procedure is necessary for those packages where the
  # default branch is not master and master does not exist.
  my $output = `(cd \"${path}\" && { git checkout develop || git checkout -b develop; } && { git checkout master || git checkout -b master; } && git flow init -fd && git checkout develop) 2>&1`;
  if ($? == 0) {
    # If we had to create any branches, inform the user how they should
    # be pushed.
    my @branch_check = `( cd \"${path}\" && git branch -a ) 2>&1`;
    $? == 0 or error("Unable to execute git branch -a to examine branches.");
    foreach my $branch (qw(develop master)) {
      grep m&\borigin/$branch\b&, @branch_check or
        report("Branch $branch has been created: when pushing upstream, use `git push -u' to configure future pull operations.");
    }
  } else {
    error("Unable to initialize git flow in $path: exit, code ",
          $? >> 8, ", output:\n", $output);
  }
}

####################################
# hub_fork - Run hub fork for the specified repository.
#
# Usage: hub_fork($destination)
#
sub hub_fork($) {
  my $destination = shift;
  report("Forking Github repo for $destination", -level => 'VERBOSE');
  my $path = File::Spec->catdir($ENV{MRB_SOURCE}, $destination);
  my $output = `(cd \"${path}\" && hub fork --remote-name=origin) 2>&1`;
  if ($? == 0) {
    my $remote = `(cd \"${path}\" && git remote | grep -v upstream | head -1) 2>&1`;
    $? == 0 or error("Forked repo $remote is not defined.");
    # If we had to create any branches, inform the user how they should
    # be pushed.
    my @remotebranches= `( cd \"${path}\" && git branch -a | grep remotes ) 2>&1`;
    $? == 0 or error("Unable to execute git branch -a to examine all branches.");
    report("remote branches:\n @remotebranches\n",-level => 'VERBOSE');
    my @localbranches=`( cd \"${path}\" && git branch -a | grep -v remotes | tr '*' ' ') 2>&1`;
    $? == 0 or error("Unable to execute git branch -a to examine all branches.");
    report("local  branches:\n @localbranches\n", -level => 'VERBOSE') ;
    foreach my $branch (@localbranches) {
      $branch  =~  s/^\s+|\s+$//g;
      $remote  =~  s/^\s+|\s+$//g;
      if(grep m&remotes/$remote/$branch&, @remotebranches) {
        my $out = `(cd \"${path}\" && git branch --set-upstream-to $remote/$branch) 2>&1`;
        $? == 0 or report($out);
      } else {
        report("Branch `$branch' has been created: when pushing upstream, use `git push -u $remote $branch' to configure future pull operations.");
      }
    }
  } else {
    error("Unable to hub fork in $path: exit, code ",
          $? >> 8, ", output:\n", $output);
  }
}

####################################
# update_cmake - Add an entry for the specified product to
#                CMakeLists.txt.
#
# Usage: update_cmake($destination)
sub update_cmake {
  my $destination = shift;
  my $product_deps = File::Spec->join("$destination", "ups", "product_deps");
  if (-e $product_deps) {
    my $parent_line = `grep -e '^parent' "$product_deps"`;
    my ($parent) = ($parent_line =~ m&^parent\s+(\w+)&o);
    if ($parent ne $destination) {
      error("$product_deps specifies product name $parent but you have checked the repo out as $destination.",
            "\nPlease rectify either by renaming the top level directory or correcting the parent line in $product_deps.",
            "\nThen, add to CMakeLists.txt with add_to_cmake.sh \"$ENV{MRB_SOURCE}\" \"<product>\".");
    }
    my $cmakeliststxt = File::Spec->join($ENV{MRB_SOURCE}, "CMakeLists.txt");
    my $check_cmake_entry_cmd =
      sprintf("grep -q -e '(%s)' '$cmakeliststxt' >%s 2>&1",
              $destination,
              File::Spec->devnull());
    my @update_cmake_cmd = ("add_to_cmake.sh", "$ENV{MRB_SOURCE}", "${destination}");
    (system($check_cmake_entry_cmd) == 0 and
     (report("CMakeLists.txt entry for product $destination already exists"), 1)) or
       (system(@update_cmake_cmd) == 0 and
        (report("Entry added to CMakeLists.txt for product ${destination}.",
                -level => "VERBOSE"), 1)) or
                  error("Unable to add product $destination to CMakeLists.txt");
  } else {
    report("Product ${destination} does not appear to have a ${product_deps} file: not adding to CMakeLists.txt.",
           "\nExecute add_to_cmake.sh \"$ENV{MRB_SOURCE}\" \"${destination}\" when you have created it.",
          -level => "WARNING");
  }
}

####################################
# get_repo - Execute all operations for the repo as specified by the
#            given repo_info hash.
#
# Usage: get_repo(%repo_info)
sub get_repo(\%) {
  my $repo_info = shift;
  if ($options->{"read-only"} and exists $repo_info->{user_url}) {
    report("Read-only global specification ignored for repo $repo_info->{repo} with user-specified url $repo_info->{user_url}",
           -level => "INFO")
  }
  my $type = $repo_info->{type};
  error("Repo type ${type} not supported for checkout of $repo_info->{product}")
    unless exists $repo_info->{$type};
  if ($type eq "github" and $options->{"github-org"}) {
    # Update the github info hash with updated github org / user.
    $repo_info->{$type} = {%{$repo_info->{$type}},
                           %{github_repo($repo_info->{$type}->{repo}, $options->{"github-org"})->{$type}}};
  }
  my $destination = $options->{destination} ||
    $repo_info->{product} ||
    basename($repo_info->{repo});
  if (-e $destination) {
    report("Repository $repo_info->{repo} already exists at $destination.",
           -level => "WARNING");
  } else {
    my $url = verified_url($type, $repo_info->{$type});
    clone_repo($url, $destination);
  }
  # Post-processing for checked-out repository.
  if (exists $repo_info->{$type}->{post}) {
    if ($options->{"dry-run"}) {
      report("Would apply post-processing to checked-out repository $destination.",
            -level => "INFO");
    } else {
      &{$repo_info->{$type}->{post}}($destination)
    }
  }
  my $tree_ish = $repo_info->{"tree-ish"} || $global_tree_ish;
  if ($tree_ish) {
    if ($options->{"dry-run"}) {
      report("Would check out $tree_ish for repository $destination",
             -level => "INFO");
    } else {
      checkout_tree_ish($destination, $tree_ish) if $tree_ish;
    }
  }
  if ($options->{"dry-run"}) {
    report ("Would update CMakeLists.txt for checked-out repository $destination.",
            -level => "INFO");
  } else {
    update_cmake($destination);
  }
}

####################################
# expand_and_process_repo_specs - Process all non-option arguments.
#
# Usage: expand_and_process_repo_specs(@repo_specs)
sub expand_and_process_repo_specs {
  my @repo_specs = @_;
  my @expanded_specs = ();
  while (my $repo_spec = shift @repo_specs) {
    my @suite_items = $options->{"no-expand"} ?
      () :
      expand_suite(${repo_spec});
    if (@suite_items) {
      report(sprintf("Expanded $repo_spec to %s items: %s",
                     scalar @suite_items,
                    join(", ", @suite_items)),
             -level => "VERBOSE");
      unshift @repo_specs, @suite_items;
    } else {
      push @expanded_specs, $repo_spec;
    }
  }
  if (scalar @expanded_specs > 1) {
    if ($options->{destination}) {
      error("Destination specification is meaningless if multiple repositories are specified.");
    } elsif ($options->{commit}) {
      error("Commit specification is meaningless if multiple repositories are specified.");
    }
  }
  foreach my $repo_spec (@expanded_specs) {
    report("Processing repo specification $repo_spec", -level => "VERBOSE");
    my %repo_info = process_repo_spec($repo_spec);
    get_repo(%repo_info);
  }
}

####################################
# longest string - ascertain the longest argument.
#
# Usage: longest_string(@args)
#
# Returns the longest argument in the provided list.
sub longest_string {
  my $max = -1;
  my $max_ref;
  for (@_) {
    if (length > $max) {
      $max = length;
      $max_ref = \$_;
    }
  }
  return $$max_ref;
}

####################################
# print_version - Print the version of this program.
#
# Usage: print_version()
sub print_version() {
  print "${prog} ${version}\n";
}

####################################
# print_repo_types - Print the known repository types.
#
# Usage: print_repo_types()
sub print_repo_types {
  print "Known repository types: \n\n";
  my $unimplemented;
  foreach my $type (sort keys %{$repo_handlers}) {
    my $handler = $repo_handlers->{$type};
    $handler or $unimplemented = 1;
    printf "  %s%s\n", $type, (defined $handler) ? "" : " (unimplemented)";
  }
  print "\nN.B. If a desired repository type is missing or currently unimplemented, ", repo_type_request("<type>"), "\n"
    if ($unimplemented);
}

####################################
# print_known_repos - Print the known repositories and their pertinent
#                     information.
sub print_known_repos() {
  print "Known repositories: \n\n";
  my $rl = length longest_string(map { my $repo_info = $_;
                                       map { $repo_info->{$_}->{repo}; } @{$repo_info->{types}};
                                     } @known_specs);
  my $pl = length longest_string(map { $_->{product}; } @known_specs);
  my $tl = length longest_string(grep { defined $repo_handlers->{$_}; }
                                 sort keys %$repo_handlers);
  my $url_indent = ' ' x ($rl + $pl + $tl + 12);
  printf "%-${rl}s    %-${pl}s    %-${tl}s    URLs\n", "Repository", "Product", "Type";
  foreach my $repo_info (@known_specs) {
    foreach my $type (@{$repo_info->{types}}) {
      my $typed_repo = $repo_info->{$type};
      printf("%-${rl}s    %-${pl}s    %-${tl}s    %s\n",
             $typed_repo->{repo},
             $repo_info->{product},
             $type,
             join(",\n$url_indent",
                  ($typed_repo->{user_url} || (),
                   $typed_repo->{rw_url} ? "$typed_repo->{rw_url} (r/w)" : (),
                   $typed_repo->{ro_url} ? "$typed_repo->{ro_url} (r/o)" : ())));
    }
  }
}

####################################
# print_known_suites - Print the known suites and their pertinent
#                      information.
sub print_known_suites() {
  print "Known suites: \n\n";
  my $sl = length longest_string(map { "${_}_suite"; } keys %{$known_suites});
  printf "%-${sl}s    Repositories\n", "Suite";
  print map { sprintf("%-${sl}s    %s\n",
                      "${_}_suite",
                      join(" ", @{$known_suites->{$_}})); }
    sort keys %{$known_suites};
}

########################################################################
# Main code.
init_known_products();

GetOptions($options,
           "help|h|?",
           "branch|b=s",
           "commit|c=s",
           "destination|directory|product|d=s",
           "dry-run|n",
           "github-org|ghorg|ghuser|g=s",
           "help-repos",
           "help-suites",
           "help-repo-types",
           "no-expand",
           "quiet|q",
           "read-only|r",
           "repo-type=s",
           "tag|t=s",
           "verbose|v",
           "version|V",
          ) or pod2usage(-exitval => 2, -width => 132);

if ($options->{help}) {
  pod2usage(-exitval => 1, -verbose => 3);
} elsif ($options->{"help-repo-types"}) {
  print_repo_types();
  exit(1);
} elsif ($options->{"help-repos"}) {
  print_known_repos();
  exit(1);
} elsif ($options->{"help-suites"}) {
  print_known_suites();
  exit(1);
} elsif ($options->{version}) {
  print_version();
  exit(1);
}

my @tree_ish_args = grep m&(branch|commit|tree)&, sort keys %{$options};

if (scalar @tree_ish_args > 1) {
  error("Mutually-exclusive tree-ish options specified: ",
        join(",", @tree_ish_args));
}

$global_tree_ish =
  $options->{branch} || $options->{commit} || $options->{tag} || undef;

my @REP = @ARGV;

scalar @REP or
  error("No products specified!", -exitval => 2, -usage => 1);

$ENV{MRB_SOURCE} or
error("MRB_SOURCE must be defined and non-empty: source the appropriate localProductsXXX/setup");

chdir($ENV{MRB_SOURCE}) or
error("Unable to change directory to MRB_SOURCE ($ENV{MRB_SOURCE})");

if ($options->{destination} and
    scalar File::Spec->splitdir($options->{destination}) > 1) {
  error("Destination specification must be a name, not a path.");
}

expand_and_process_repo_specs(@REP);

1;

=pod

=head1 NAME

mrb gitCheckout - Clone one or more git repositories or suites to your development area.

=head1 SYNOPSIS

B<mrb gitCheckout|g> B<-h|--help|-?> | B<--help-repo-types> | B<--help-repos> | B<--help-suites>

B<mrb gitCheckout|g> B<-V>

B<mrb gitCheckout|g> [B<-b|--branch> I<branch> | B<-c|--commit> I<commit> | B<-t|--tag> I<tag>] [B<-d|--destination|--directory|--product> I<name>] [B<--dry-run|-n>] [B<--github-org|--ghorg|-g> I<ghorg>] [B<--no-expand>] [B<-q|--quiet>] [B<-r|--read-only>] [B<--repo-type> I<type>] [B<-V|--version>] [B<-v|--verbose>] [--] I<spec>+

B<+> implies optional repeated arguments.

I<spec> may be a suite, product name, repository name or URL. For a full explanation of this flexibility, see section L</ARGUMENTS> with B<--help>.

=head1 DESCRIPTION

mrb gitCheckout facilitates the ordered checkout of one or more repositories or suites. It knows about many suites and common products. In addition to cloning the repository, mrb gitCheckout will initialize git flow and add an entry to the F<CMakeLists.txt> file if necessary.

=head2 OPTIONS

=over 2

=item B<--branch> I<branch>

=item B<-b> I<branch>

After cloning, check out the specified I<branch>. Mutually-exclusive with B<--commit> and B<--tag>. Overridden by per-repository I<tree-ish> specification (see L</ARGUMENTS>).

=item B<--commit> I<commit>

=item B<-c> I<commit>

After cloning, check out the specified I<commit>. Mutually-exclusive with B<--branch> and B<--tag>. Overridden by per-repository I<tree-ish> specification. It is an error to specify --commit with multiple repository specifications.

=item B<--destination> I<name>

=item B<--directory> I<name>

=item B<-d> I<name>

=item B<--product> I<name>

Clone the repository into the specified I<name>. It is an error to specify B<--directory> with multiple repository specifications. It is an error to specify B<--directory> if it is inconsistent with a product's name as specified in F<ups/product_deps>. This option overrides the I<product> component of I<spec>, if given. The latter, however, is the recommended mechanism for specifying the product name as it is more flexible and specific.

=item B<--dry-run>

=item B<-n>

Don't actually check out any repositories.

=item B<--github-org> I<ghorg>

=item B<--ghorg> I<ghorg>

=item B<-g> I<ghorg>

Use the provided ghorg for github checkouts. Overrides known repository information (see B<--help-repos>); is in turn overridden by specified URIs.

=item B<--help>

=item B<-h>

=item B<-?>

This help.

=item B<--help-repos>

Print the list of known repositories and their main attributes.

=item B<--help-suites>

Print the list of known suites and their repositories.

=item B<--help-repo-types>

Print the list of known repository types.

=item B<--no-expand>

Disable the expansion of known suites, repositories and products.

=item B<--quiet>

=item B<-q>

Print only warnings and errors (overridden by B<--verbose>).

=item B<--read-only>

=item B<-r>

Check out the repository in read-only mode.

=item B<--repo-type> I<repo-type>

Specify the repository type as I<repo-type>. Overridden by per-repository I<type> specification (see L</ARGUMENTS>).

=item B<--tag> I<tag>

=item B<-t> I<tag>

After cloning, check out the specified I<tag>. Mutually-exclusive with B<--branch> and B<--commit>. Overridden by per-repository I<tree-ish> specification (see L</ARGUMENTS>).

=item B<--verbose>

=item B<-v>

Increase verbosity (overrides B<--quiet>).

=item B<--version>

=item B<-V>

Print version.

=back

=head2 ARGUMENTS

A I<spec> may be:

=over 2

=item I<suite>[@I<branch|tag>]

If known, suite is expanded to its list of repositories, otherwise I<spec> is interpreted per below. See B<--help-suites> for a table of known suites. This form is not available if the B<--no-expand> option is used. While B<mrb gitCheckout> is not capable of detecting the specification of a commit rather than a branch or tag here, its use is contraindicated and will almost certainly not do what you want.

=item [I<product>%]I<URL>[@I<branch|commit|tag>]

If not specified, I<product> is inferred from the basename of the URL.

=item S<[I<product>%] [I<type>:]I<repo>[%I<user>] [@I<branch|commit|tag>]>

=item [I<type>:]I<product>[@I<branch|commit|tag>]

[Spaces in the above are for formating clarity only and should be omitted in actual usage.]

If not specified, I<type> defaults to C<fnal>, or as specified with B<--repo-type>. See B<--help-repo-types> for a full list of known types.

If not specified, I<product> defaults to I<repo> and vice-versa.

If a known product or repository is recognized, internal information is used and conflicting user-provided information is ignored. If this behavior is not what is desired, use the I<URL> form for I<spec> or the B<--no-expand> option.

=back

=head2 EXAMPLES

=over 4

=item B<mrb g> larsoft_suite@v07_01_00

=item B<mrb g> -t v07_01_00 larsoft_suite

Check out all the constituent repositories of the larsoft suite at the specified suite version.

=item B<mrb g> -r art@art-v2-develop

Check out the (known) art repository on the specified branch in read-only mode.

=item S<B<mrb g> -v my_repo%fnal:my-prj_my-repo%my-prj@feature/cool-stuff>

=item S<B<mrb g> -v -b feature/cool-stuff my_repo%fnal:my-prj_my-repo%my-prj>

Check out the B<feature/cool-stuff> branch of the C<my-repository_my-repo> branch from FNAL Redmine as the product C<my_repo> with the URL as calculated to be C<ssh://p-my-prj@cdcvs.fnal.gov/cvs/projects/my-prj_my-repo>, per the rules for FNAL Redmine repositories. Provide verbose messages.

=back

=cut

