# NO USER-SERVICEABLE PARTS BELOW.
#
# There should be as little as possible here,
# with most of the heavy lifting done by other small scripts
#
# When sourcing this file from a script, you may have to tell this
# source file where it is via the fw_db shell (or env) variable.
# I.e.:
#    set fw_db=/some/path; source /some/path/this_file
# or  fw_db=/some/path; . /some/path/this_file

set_ msg1='ERROR: You MUST setup ups'
test -z $UPS_DIR && ( echo ""; echo "$msg1"; echo "" ) && return

set_ msg3='ERROR: You MUST specify either -o, -p, or -d'
set_ msg4='Usage: setEnv <-d|-o|-p> <qualifier list>'

# make sure we know where this script lives
# now if we were passed a path or if not, we can figure it out (maybe if we are interactive)
#   bash, zsh, ksh and tcsh pass params to a source file, csh does not. but someone will be writing csh scripts
set_ msg2='Please set shell or env. variable fw_db (to be the path to the framework source code). Fix this and other errors may go away.'
tnotnull fw_db && set_ db=`sh -c "cd $fw_db >/dev/null 2>&1 && pwd"` && vecho_ 'setting db from fw_db variable' || set_ db=

test -z "$db" && tnotnull BASH_SOURCE && set_ me=`dirname $BASH_SOURCE` && set_ db=`sh -c "cd $me >/dev/null 2>&1 && pwd"` && vecho_ 'setting db via BASH_SOURCE'

# history is applicable only for interactive t/csh
test -z "$db" -a "$ss" = csh && test $?history = 0 && set history=5  # make sure history 1 works
test -z "$db" -a "$ss" = csh && set me=`history 1|sed 's/^[ 	0-9:]*//'` && test -n "$me" && set me=`dirname $me[2]` \
    && set db=`sh -c "cd $me >/dev/null 2>&1 && pwd"` && vecho_ 'setting db via interactive history'
ifcsh_
else
    # Special trick for zsh.
    test -z "$db" && test "${shell%%*/}" = "zsh" && db=${${(%):-%N}%/*}
# Warning, this must be here because the tcsh parser is brain-dead.
endif
endifcsh_
#echo This script lives in $db

test -z "$db" && echo "$msg2" || vecho_ "db=$db"
test -n "$db" && setenv CETPKG_SOURCE $db

# make sure we know the current directory
tnotnull MRB_BUILDDIR  && setenv CETPKG_BUILD $MRB_BUILDDIR
test -z "$CETPKG_BUILD" && setenv CETPKG_BUILD `pwd`
tnotnull MRB_SOURCE  && setenv CETPKG_BUILD $MRB_SOURCE
test -z "$CETPKG_SOURCE" && setenv CETPKG_SOURCE `pwd`

#echo The working build directory is $CETPKG_BUILD
#echo The source code directory is $CETPKG_SOURCE

# make sure we know the local product directory
set_ msg6='ERROR: MRB_INSTALL is not defined - please source localProducts_XXX/setup'
test -z "$MRB_INSTALL" && ( echo ""; echo "$msg6"; echo "" ) && return
echo local product directory is $MRB_INSTALL

set_ msg5='ERROR: setup of required products has failed'
set_ msg3='ERROR: $MRB_DIR/bin/get_setup_list.sh has failed'

# Remove build directory from FHICL_FILE_PATH
tnotnull FHICL_FILE_PATH && setenv FHICL_FILE_PATH `dropit -p $FHICL_FILE_PATH $MRB_BUILDDIR`

# Remove build area LIBRARY_PATH
tnotnull LD_LIBRARY_PATH   && setenv LD_LIBRARY_PATH   `dropit -p $LD_LIBRARY_PATH   $MRB_BUILDDIR`
tnotnull DYLD_LIBRARY_PATH && setenv DYLD_LIBRARY_PATH `dropit -p $DYLD_LIBRARY_PATH $MRB_BUILDDIR`

echo ----------- check this block for errors -----------------------

source `${UPS_DIR}/bin/ups setup ${SETUP_UPS}`
setenv UPS_OVERRIDE -B
# now get the rest of the products
set_ cmdfile=`$db/get_setup_list.sh $*`
test "$setup_fail" = "true" && echo "$msg3"
chmod +x $cmdfile
#echo Ready to source $cmdfile
source "$cmdfile"
#echo "$cmd returned $setup_fail"
test "$setup_fail" = "true" && echo "$msg5"
test "$setup_fail" = "true" && unset setup_fail && return 1

echo ----------------------------------------------------------------

# cleanup before exiting
rm -f "$cmdfile"
