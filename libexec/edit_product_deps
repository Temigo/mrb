#!/usr/bin/env perl
#

# parse and update product_deps

use strict;

use warnings FATAL =>
  qw(io regexp severe syntax uninitialized void);;

use Cwd qw(:DEFAULT chdir abs_path);
use File::Basename;
use File::Spec; # For catfile;
use IO qw(File Handle);
use vars qw($_mydir);

BEGIN {
  my $_me = readlink($0);
  if (not $_me) {
    $_me = $0;
  } elsif ($_me !~ m &^/&) {
    $_me = abs_path(File::Spec->catfile(dirname($0), $_me));
  }
  $_mydir = dirname($_me);
}

use lib $_mydir;
use parse_deps qw(:VERSION :DIAG);
use warnings FATAL => 'parse_deps';

if( $#ARGV < 3 ) {
    print "\n";
    print "ERROR: unspecified parameters - only have $#ARGV \n";
    print "USAGE: edit_product_deps <file> <product> <version> <dryrun:yes|no>\n";
    exit 1;
}

my $pdfile = $ARGV[0];
my $product = $ARGV[1];

error_exit("ill-formed new version: $ARGV[2]")
  unless $ARGV[2] =~ m&^(?<quote>["']?)(?<ver>.*)\g{quote}$&;
my $new_version = to_ups_version($+{ver});
my $dryrun = ($ARGV[3] // '') =~ m&^(y(?:es)?|1|t(?:rue))&;

my ($pdfilenew, $fh_out);

if ($dryrun) {
  notify("[DRY RUN]: these changes will be made:\n\n");
} else {
  $pdfilenew = "$pdfile.new";
  info("writing $pdfile as $pdfilenew\n\n");
  $fh_out = IO::File->new("$pdfilenew", ">") or
    error_exit("failed to open $pdfilenew for write");
}

my $changed;
my $get_phash="";
my $get_quals="";
my $get_fragment="";
my $fh_in = IO::File->new("$pdfile", "<") or
  error_exit("failed to open $pdfile for read");

while (my $line = <$fh_in>) {
  chomp $line;
  my $newline = $line;
  if ($newline =~ s&^(\s*parent\s+\Q$product\E\s+)[^#\s]+&$1$new_version& or
      ($get_phash eq "true" and
       $newline =~ s&^(\s*\Q$product\E\s+)[^-\s]\S+&$1$new_version&)) {
  } elsif ($line =~ m&^\s*parent\s+\Q$product\E&) {
    info("version information for $product is set by project() in %s/CMakeLists.txt\n",
         dirname(dirname($pdfile)));
  } elsif ($line =~ m&^\s*product\b&) {
    $get_phash="true";
  } elsif ($line =~ m&^\s*end_product_list\b&) {
    $get_phash="";
  }
  if ($newline ne $line) {
    ++$changed;
    if ($dryrun) {
      print <<EOF;
  ----------------------------------
  old line: $line
  ==================================
  new line: $newline
  ++++++++++++++++++++++++++++++++++
EOF
    } else {
      $line = $newline;
    }
  }
  $fh_out->print("$line\n") if $fh_out;
}
$fh_out->close() if $fh_out;
$fh_in->close();

if ($changed) {
  if ($dryrun) {
    notify(sprintf("[DRY_RUN] would have made $changed edit%s to $pdfile\n",
                   ($changed != 1) ? 's' : ''));
  } else {
    rename($pdfile, "$pdfile.bak") or error_exit("failed to save backup $pdfile.bak ($!)");
    rename($pdfilenew, $pdfile) or error_exit("failed to install $pdfilenew as $pdfile ($!)");
    info(sprintf("made $changed edit%s to $pdfile\n",
                 ($changed != 1) ? 's' : ''));
    my $colordiff = (system("type -t colordiff >/dev/null 2>&1") == 0) ? ' | colordiff' : '';
    verbose(`diff -u "$pdfile.bak" "$pdfile"$colordiff`);
  }
} else {
  info(($dryrun) ? "[DRY_RUN] " : '',
       "no changes necessary to $pdfile",
       ($pdfilenew and -e $pdfilenew) ? ": removing $pdfilenew" : '');
  unlink $pdfilenew if ($pdfilenew and -e $pdfilenew);
}

1;
